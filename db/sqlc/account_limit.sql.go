// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account_limit.sql

package db

import (
	"context"
)

const getAccountLimit = `-- name: GetAccountLimit :one
SELECT account_id, daily_transfer_limit, created_at, updated_at FROM account_limits
WHERE account_id = $1 LIMIT 1
`

func (q *Queries) GetAccountLimit(ctx context.Context, accountID int64) (AccountLimit, error) {
	row := q.db.QueryRow(ctx, getAccountLimit, accountID)
	var i AccountLimit
	err := row.Scan(
		&i.AccountID,
		&i.DailyTransferLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAccountLimit = `-- name: UpsertAccountLimit :one
INSERT INTO account_limits (
  account_id,
  daily_transfer_limit
) VALUES (
  $1, $2
)
ON CONFLICT (account_id)
DO UPDATE SET
  daily_transfer_limit = EXCLUDED.daily_transfer_limit,
  updated_at = now()
RETURNING account_id, daily_transfer_limit, created_at, updated_at
`

type UpsertAccountLimitParams struct {
	AccountID          int64 `json:"account_id"`
	DailyTransferLimit int64 `json:"daily_transfer_limit"`
}

func (q *Queries) UpsertAccountLimit(ctx context.Context, arg UpsertAccountLimitParams) (AccountLimit, error) {
	row := q.db.QueryRow(ctx, upsertAccountLimit, arg.AccountID, arg.DailyTransferLimit)
	var i AccountLimit
	err := row.Scan(
		&i.AccountID,
		&i.DailyTransferLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
